# [문제](https://www.acmicpc.net/problem/3085)  
상근이는 어렸을 적에 "봄보니 (Bomboni)" 게임을 즐겨했다.

가장 처음에 N×N크기에 사탕을 채워 놓는다. 사탕의 색은 모두 같지 않을 수도 있다. 상근이는 사탕의 색이 다른 인접한 두 칸을 고른다. 그 다음 고른 칸에 들어있는 사탕을 서로 교환한다. 이제, 모두 같은 색으로 이루어져 있는 가장 긴 연속 부분(행 또는 열)을 고른 다음 그 사탕을 모두 먹는다.

사탕이 채워진 상태가 주어졌을 때, 상근이가 먹을 수 있는 사탕의 최대 개수를 구하는 프로그램을 작성하시오.
## 입력  
첫째 줄에 보드의 크기 N이 주어진다. (3 ≤ N ≤ 50)

다음 N개 줄에는 보드에 채워져 있는 사탕의 색상이 주어진다. 빨간색은 C, 파란색은 P, 초록색은 Z, 노란색은 Y로 주어진다.

사탕의 색이 다른 인접한 두 칸이 존재하는 입력만 주어진다.
## 출력  
첫째 줄에 상근이가 먹을 수 있는 사탕의 최대 개수를 출력한다.


## 입출력 예   
```3  
CCP  
CCP  
PPC  
return 3  
4  
PPPP  
CYZY  
CCPY  
PPCC   
return 4  
5
YCPZY
CYZZP
CCPPP
YCYZC
CPPZZ
return 4
```

## 풀이  
완전 탐색으로 풀었음  
1. 인접한 좌우 색을 바꿔서 가장 긴 연속 부분을 카운팅
1. 인접한 상하 색을 바꿔서 가장 긴 연속 부분을 카운팅
1. 1~2의 과정을 반복하며 swap할 수 있는 모든 경우를 탐색

## 코드  

```python
import sys
input = sys.stdin.readline
#입력 받기
n=int(input())
data=[list(input())for _ in range(n)]

answer=0
# 같은 색 탐색
def search():
    global answer
    # 가로로 탐색
    for i in range(n):
        count_r=1
        for j in range(n-1):
            if data[i][j]==data[i][j+1]:
                count_r+=1
                answer=max(answer,count_r)
            else:
                count_r=1
    # 세로로 탐색
    for i in range(n):
        count_c=1
        for j in range(n-1):
            if data[j][i]==data[j+1][i]:
                count_c+=1
                answer=max(answer,count_c)
            else:
                count_c=1
        
for i in range(n):
    for j in range(n-1):
        # 인접한 좌우 색을 swap해서 탐색
        data[i][j],data[i][j+1]=data[i][j+1],data[i][j]
        search()
        data[i][j+1],data[i][j]=data[i][j],data[i][j+1]
        # 인접한 위아래 색을 swap해서 탐색
        data[j][i],data[j+1][i]=data[j+1][i],data[j][i]
        search()
        data[j+1][i],data[j][i]=data[j][i],data[j+1][i]
print(answer)
```
